# 违例

一般的希望在编译器就将所有的错误检查出来，然后就将其改正。但是有的必须是在运行的时候才可以检测出来，那么这个时候怎么处理它？？？

c++早期是通过几种手续达到目的，它作为一种规定建立起来，不是程序设计的一部分。

- 返回一个标志位或者一个值，接收者检查这些值或者标志，判断发生的事情。（有弊端）这种每次都需要进行检查，会降低代码的可读性也可能大幅度降低

## 基本违例

"违例"表示在出现什么问题的时候应该中止方法或者作用域继续。

- 区分违例和普通问题
    - 普通问题我们根据已有的信息，对问题进行处理。
    - 违例它是无法运行的时候，本地没有足够的解决问题的信息，必须跳出当前。

-  产生违例会发生什么？
    - 违例会在当前的路径无法进行的状态下，会重新走一个路径，让程序继续执行。

- 违例的处理方式？
    - 直接处理
    - 将其抛出去

###  违例自变量

和java一样，需要使用new在堆中创建违例对象，并调用一个构建器。存在两个构建器：默认   自变量字符串

throw做什么？
    - 执行new创建一个不在程序常规执行范围内的对象 
    - 对象从方法中返回  它可以理解为一种返回机制   先返回一个值 在推出方法或者作用域

### 违例的捕获

某个方法产生一个违例，保证可以被捕获，并获得正确对待，对于java违例机制，好处就是我们可以解决问题。
前提: 明确警戒区    它代表一个代码区域

- try块
try是不离开，还继续的进行执行
```java
try{
    
}
```

好处就是在产生不正常现象的时候，可以将其进行统一的处理。违例控制器（及就是每一种catch块），根据不同的违例进入不同的位置，它和switch的区别在于，switch需要一个break。

违例可以保证代码可以继续的进行。

### 保证客户端一定处理异常

一个方法或者类，往往会给别人调用，那么我们需要通知它们进行一定的违例处理，这个关键字使用throws.我们定义方法的时候，可以将可能产生的违例抛出去，然后在调用的时候必须的去处理他们。

### 捕获的异常

- 书写规范
    - 先写小的，在写大的
    - 如果前面已经处理，后续的将不会在进行处理。

Throwable打印出堆栈路径

### 捕获异常，重新抛出

首先我们抛出一次异常，使用catch进行捕获，随后我们在进行一次抛出。这样做的好处是我们可以将大的违例变为一个小的违例。

### java的标准违例

java中的Throwable对所有的违例进行描述，它包括了error和exception，error一般不需要处理，仅仅需要处理的exception

- 运行时异常
这类的异常是不需要进行捕获的，只需要将它们定义就可以了，吧它们直接当作错误处理。
如果发生代码就会停止掉

### 自定义违例

### 违例的限制

