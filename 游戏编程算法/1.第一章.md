# 游戏算法

## 游戏循环 
 一个核心流程的控制称为游戏循环，迭代游戏一次称为1帧，大部分是30~60帧，如果一游戏是60FPS，那么就是每秒执行60次‘

## FPS

一次游戏循环每次执行的次数。

## 传统的游戏循环

```
while(1)
    用户输入：各类输入设备
    更新世界：激活所有的对象
    生成输出：最耗费性能的是2D和3D
loop
```

## 多线程下的游戏

CPU可以执行多个指令
游戏需要处理的计算比较多的时候就需要多个线程来达到需要的指定帧数范围内，主线程会将交给第二线程进行处理，第二线程可以处理渲染

- 问题1 ： 主线程干什么？？
    - 如果主线程将数据交给其它线程处理，自己等，那么就会变得更加慢，所以处理方法就是渲染线程比主线程慢一帧
    - 缺点：会使得渲染慢一帧

    对实时要求比较高的游戏是完全不可取的。

## 时间和游戏

- 真实时间和游戏时间

问题1：区分

- 通过处理时间增量来表示游戏逻辑

问题1：为什么需要？
    在不同的处理器上，游戏的处理速度不同，8MHZ 16MHZ游戏的速度会不同
    为了解决问题,引入了增量时间 ，不能简单的通过帧数来改变移动的像素点。

伪代码
```
enemy.position.x += 5;//之前
enemy.position.x += 5*deltaTime;
```
上面保证了移动的速度是一样的。每个属性的变化通过增量去处理

问题2：如何计算
    已知上一帧流逝的真实时间（取决于框架），计算真实时间，取决于游戏的状态，也有可能就是乘上一个因子。

```
真实时间
真实时间*因子

进程输入

更新状态

渲染输出
```

问题3：上面的并不能解决所有问题，如果与物理相关的，是数值积分的原因，比如低帧跳的很高
解决方法：
- 限制帧率
- 如果某帧率比目标的帧率还要长，那么就可以丢弃帧的方法解决，这个时候就会出现卡顿。

## 游戏对象

广义：每一帧需要更新或者绘制的对象（不一定非要使用传统的面向对象来处理）‘

- 游戏对象的类型
任何的游戏角色和生物可以移动的物体都需要在游戏阶段进行更新，还需要进行输出的时候渲染

对象：
- 静态对象：只绘制不更新的对象
- 任何需要绘制的对象
- 需要更新但是不需要绘制的对象

## 游戏循环中的游戏对象

- 表示游戏对象
    面向对象中的接口（契约）

- 基础游戏对象类
```
class GameObject

end
```
游戏中所以公共的都应该放在基类中，生命两个接口，一个draw对象，另一个是Update对象

```
interface Drawable
    function Draw()
end

interface Updateable
    function Update(float deltaTime)
end
```