# 垃圾回收的概念与算法

java提供了全套自动内存管理方案，减少内存管理的工作量

- 什么是垃圾回收机制

- 常见的算法

## GC

内存中特定内存中不会在使用的对象

## 垃圾回收算法

常见的算法：

- 引用计数器
- 标记压缩法
- 标记清除法
- 复制算法
- 分代分区


### 引用计数器

引用计数的方法，就是如果有引用就+1，没引用就-1，失效的时候为0

问题：循环引用   加减对性能的影响

### 标记清除

首先分为两个阶段：一种是标记阶段，通过根，从根开始寻找可达对象，未被标记或者未被引用的就是垃圾对象。

问题：回收后内存地址不连续

### 复制算法

将内存分为两块，每次使用一块，回收的时候，将存活的复制到未使用的内存中，每次都进行互换角色。对于大量不存活的来说，非常的快，也不会存在碎片。

对于新生代就使用的是复制算法   大对象或者新生代内存不足也会直接进入到老年代

### 标记压缩

复制算法建立在存货的对象少的情况、垃圾多的情况。对于老年代一般是大对象或者长期存活的对象，复制就很慢了。标记压缩是一种老年代的回收算法。它不仅仅是标记清除，而且还会将数据存放到内存的一端。最好清理边界外的。

### 分代算法

将内存分为几块区域，对于不同的区域使用不同的回收算法。新生区存活一般较低，使用复制算法，老年代认为是长期存活的，所以使用标记压缩。

标记是否存活使用的是根寻找节点的方式，比如老年期存在年轻代的引用问题，使用了card table,标记老年代的某一个区域所有的对象是否持有新生代的对象引用，不需要扫描所有的老年代，只有当卡表值为1的时候才给特定区域开始扫描，每个卡表对应的是4k的区域。

### 分区算法

按照生命周期的长短分为连续不同的小区域 每个小区域单独使用，单独回收。

一般的堆空间越大回收时间越长  将回收区域分为若干块，根据没块停顿时间，调整大小

## 判断可达性

从根开始访问到对象，但是这种没有引用就回收是鲁莽的，比如在某种条件下存活，所有需要在某种情况下才可以回收。

- 可触及：根开始，可以到达这个对象。
- 可复活：所有的引用被释放，但是在finalize的时候存活。
- 不可触及，执行了finalize方法，仍没有存活

复活最简单的例子就是先放弃引用，然后复写finalize方法，在方法里面重新引用

### 引用和可触及性的强度

强 软 弱 虚

强引用一定不会被回收，其他几种在某种情况下都有可能被回收。

- 强引用：可以直接访问目标  不会被回收  可能会造成内存泄露
- 软引用：软引用只存在一个，当堆内存不足的时候，就会被回收\n每一个软引用都可以附带一个队列，对象的可达性发生变化的时候，会进入队列
- 弱引用：发现就会被回收
- 虚引用：必须和队列一起使用

## 停顿现象

垃圾回收过程中，会进入一个停顿的状态，终止所有的线程执行，才不会有新的垃圾产生


增加新生代，gc减少，但是每次回收消耗增加（因为发生了大量的复制）