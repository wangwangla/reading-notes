# 垃圾回收和内存分配

垃圾回收器不止一种，什么时候使用哪一种，性能有啥影响

- java虚拟机支持的垃圾收集器种类
- 串行垃圾收集器
- 并行垃圾收集器
- CMS
- G1

## 串行收集器

指的是单线程收集器，每次回收只有一个线程执行，对于并行弱的计算机有好的性能。可以使用在新生代和老年代，这个分为新生代串行和老年代串行。

### 新生代串行

串行收集器是最古老的收集器的一种，也是最基本的jdk垃圾收集器之一。
- 它仅仅使用单线程进行垃圾回收。
- 它是独占的垃圾回收

串行收集时，程序线程都需要停下，等待垃圾回收完成。

它是经历了环境考验的收集器，新生代串行收集器使用的时复制算法，实现简单、逻辑处理特别高效，没有切换线程开销。使用在单cpu处理器硬件不是很优越的场合，可以超过并行和并发。

-XX:+UseSerialGC指定可以使用的新生代串行收集器和老年代串行收集器

client模式下，它是默认的垃圾收集器。

### 老年代串行收集器

串行收集器使用的时压缩算法，它是串行的、独占式的垃圾回收器，之前说过空间越大，垃圾回收使用的时间就越长，老年代回收会发生长的时间

老年代串行回收器可以与多种新生代的配合使用

-XX:+UseSeralGC :都使用串行收集器
-XX:+UseParNewGC:新生代ParNew 老年代：串行
-XX:+UseParallelGC:新生代Parallel,老年代串行收集器

## 并行收集器

并行收集器在串行回收期的基础上做改进，使用多线程垃圾回收，对于并行计算能力强的计算机，可以缩短时间

### ParNew回收器

ParNew是一个新生代的垃圾回收器，只是简单的将串行多线程化，回收策略、算法以及参数和新生代串行回收器一样，也是独占式的，在收集过程中全部暂停，并行回收器使用的多线程进行回收，并发能力比较强的cpu上。

开启ParNew
- -XX:+UseParNewGC :新生代使用的ParNew回收器，老年代使用的是串行
- -XX:+UseConcMarkSweepGC：新生代使用ParNew回收器，老年代使用的CMS

回收器的线程数量可以使用-XX:ParallelGCThreads参数指定，一般与CPU数量相当，避免线程数量过多，影响性能。
- cpuNum   cpu<8
- CpuNum > 8   3+((5*CpuNum)/8)

### ParallelGC回收器

也是使用复制算法的收集器，他和ParNew回收器一样，使用多线程、独占式的收集器，**注重吞吐量**

开启
- -XX:+UseParallelGC:新生代使用ParallelGC回收器，老年代使用串行回收器
- -XX:+UseParallelOldGC:新生代使用ParallelGC回收器

PaeallelGC回收器提供了两个重要参数用于控制吞吐量
- -XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间，它是一个大于0的值。PGC使用时。会调整java堆大小和一些参数，将时间控制在MaxGCPauseMills以内，如果为了较小的时间，会将这个值设置小，但是会造成回收频繁。增加回收总时间，降低了吞吐量。
- -XX:GCTimeRatio:设置吞吐量大小，值时一个0到100之间的整数，假设为n，那么系统花费不超过1/(1+n)的时间用于收集，比如设置19，那么使用时间不超过1/(1+19) = 5%  一般取值时99

它还支持自适应GC调节  新生代、老年代比例会自己调整

### 老年代ParallelOldGC回收器

老年代ParallelOldGC回收器也是一种多线程的收集器，使用的也是压缩算法，jdk1.6才开始使用

使用-XX:UseParallelOldGC可以在新生地使用ParallelGC回收器，老年代使用PGC

## CMS回收器

与上面两个不同，CMS注重系统的停顿时间，并发标记消除(CMS)，标记清除算法，使用多线程并行回收的回收器。

