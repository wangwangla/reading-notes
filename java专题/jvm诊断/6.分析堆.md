# 分析堆

- 内存溢出的原因以及解决思路
- String探讨
- 分析堆
- MAT分析

## 内存溢出的原因

内存溢出是一块内存区域的耗尽，内存溢出的原因，堆内存溢出、直接内存溢出、永久区溢出等。

### 堆溢出

堆是java程序最主要的内存空间，对象是分配在堆内存上的，因此它是最容易发生内存溢出的部分，而且发生内存溢出的都是强引用，内存使用大于Xmx设置的最大值时。

异常：

```
java heap space 
```

如何缓解，使用Xmx参数指定一个更大的堆空间，对空间不可能一只变大，对堆进行优化。

### 直接内存

java Nio支持直接内存的使用，通过java代码，获取一块对外内存空间，可以向操作系统申请。直接内存申请一般比对内存慢，访问速度块（可复用，经常被访问的空间，
可以提高系统性能）

直接内存不受java控制，所以直接内存的使用不会触发gc,不会被回收（这么说也不准确，如果达到MaxDirectMemorySize就会触发）

为了保证内存不溢出的方法是合理的进行Full GC,或者设定-XX：MaxDirectMemorySize（默认等于Xmx）.
所以直接堆内存少  有gc发生  直接内存申请频繁，会比较容易导致直接内存溢出。

但是如果适时的进行gc，就会释放直接内存。

解决方法：
- 设置较小的堆，不指定MaxDirectMemorySize,堆和它是相同的。
- 设置最大值来解决

合理的显示GC

### 过多线程导致的OOM

每一个线程的开启，都需要占用系统资源，线程太多也会导致内存溢出，线程使用的空间是对外空间，所以和直接内存类似。

所以控制线程数量，可以减少栈内存的空间；可以设置减少每一个线程所占的内存空间。

但是栈空间又会溢出。

### 永久区溢出

存放的是元数据，如果存在太多的类型，永久区就会发生溢出，1.8，永久区被元数据区域替代，但是它们的功能是类似的，都是保存元信息。

解决方法：
- 增加MaxPermSize的值
- 减少系统需要的类的数量
- 减少classLoader合理的装栽各个类，并定期回收。

### GC效率低下造成OOM

GC是内存回收的关键，效率低下，造成性能受影响。
系统堆空间小，gc占用的时间就会较多，回收的内存少，回收的效率低就会造成oom

## String无处不在的串

string不是基本数据类型

### 特点

- 不变性
- 常量池优化
- 类final定义

#### 不变性

指string一旦生成，不会再对它产生改变，对象状态创建之后不在发生改变，不变可以在多线程频繁访问的时候，不需要加锁。

修改并不是通过修改完成的，是通过重新生成来完成的。

#### 常量池的优化

两个String对象拥有相同值的时候，只引用常量池的一个拷贝，当同一个字符反复出现的时候，可以节约内存空间。
