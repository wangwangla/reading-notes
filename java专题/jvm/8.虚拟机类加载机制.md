# 虚拟机类加载机制

字节码需要加载到虚拟机才可以运行和使用，虚拟机将从class文件加载到内存，对其进行校验，转换解析和初始化，最终变为虚拟机可以使用的java类型。

它的操作都是在运行的时候完成的，可以提高灵活性，到运行的时候在去指定具体的类。

**每个class文件都代表者一个类或者接口**

## 类加载的时机

类夹杂到虚拟机的内存中开始，一直到卸载，包括：加载/验证/准备/解析/初始化/使用/卸载。解析步骤可以不按照严格的顺序进行。

加载的时机：

- new getStatic putstatic invokestatic,如果没有初始化，就需要先初始化：一般为new  读取或者设置一个静态字段的时候（不包括已经放入到常量池的）。或者调用静态方法的时候。

- 方法对类进行反射调用的时候，类没有初始化就先初始化。

- 初始一个类的时候，父类没有初始化，需要先出发父类进行初始化。

- 虚拟机启动，main类，虚会先对去进初始化。

## 加载

- 加载：
    - 类的全限定名类获取定义的此类二进制字节流。
    - 字节流所代表的静态存储转为运行时数据区的数据结构
    - 在内存中生成一个class对象，作为访问的入口。

非数组类的用户控制能力更强（自己定义加载器），数组类比较小（不使用加载器，虚拟机直接创建的，但是元素类型需要类加载器去创建）

加载完成之后，二进制流就会按照虚拟机的格式存储在方法区域之中，方法中的数据存储格式由虚拟机定义。生成一个class对象，作为入口，这个对象并没有规定它的位置。

## 验证

验证是否符号要求

## 准备

正式为类变量分配内存并设置类变量加载的初始化阶段，十一点内存将在方法区进行分配**static的变量**实例变量是在堆中的，并且是**0值**

用户指定的值是在putstatic之后，在构造方法里面（在初始化的时候赋值）

**但是**如果被final修饰的变量，就直接的赋值（ConstantaValue）

javac将会为value生成ContantValue属性，在准备阶段虚拟机将根据ContantValue属性，在准备阶段虚拟机根据设置将value设置为指定值。

## 解析

将常量池的符号引用替换为直接引用的过程。

## 初始化

初始化真正的执行java代码（字节码）
初始化是通过程序指定的主管计划初始化类变量(final的已经赋过值，其他的是仅仅是零值)和其他资源，初始化是执行类 构造器 的过程。

- clinit()方法怎样生成的，执行过程会产生什么影响以及特点

    - 编译器自己收集赋值动作，静态代码块，收集顺序和源码出现顺序一致，static块只能访问定义在它之前的变量（可以赋值）。

    - 不需要显示的调用父类构造器，虚拟机会保证执行之前，父类方法已经执行完毕（最先执行的是Object）

    - 父类初始化先于子类，所以它的static初始化先于子类。

    - clinit并不是必须的，如果没有赋值操作，那么就不需要。

    - 类和接口只要存在赋值操作，那么就存在clinit方法。但是接口并不会执行父类clinit，接口实现类也不会执行。

    - 虚拟机会保证一个类的clinit在初始化的时候被枷锁同步。只会一个线程对初始化，其他的都需要堵塞。

## 类加载器

类全限定名来获取二进制的字节流，这个代码模块是"类加载器"。放在虚拟机的外面去实现。

## 类和类加载器

用于实现类加载动作，类加载器和类本身一同确定类的唯一性，每个类加载器，都拥有一个独立类名称空间。相同类加载器加载的类才有可能相同。

相等指：class对象的equals()方法/isAssignableFrom()方法/isInstance()方法返回结果和instanceof方法

## 双亲委派模型

两种：一种启动类加载器Bootstrap ClassLoader，类加载器使用c++语言实现；另一种是其他的类加载器，通过java实现，独立于虚拟机，并且继承于java.lang.ClassLoader。

- 启动类加载器

- 扩展类加载器

- 应用程序类加载器

## 双亲委派

                启动类加载器

                扩展类加载器

              应用程序类加载器

      自定义类加载器     自定义类加载器

这种模式就是双亲委派模性，除了根，其他的都有父类加载器。 