HashMap

初始化都是16，增长因子都是0.75，1.7采取的结构是数组+链表的方式。存入 数据先进行一次 数据的hash计算，然后通过计算将数据存入指定下标的数组中，数据存储1.7采用的是前插法，1.8采用了尾插。

再插入的时候会有一次扩容，扩容的时候会扩展为原理的2被 ，扩容的依据是当前的占用数据个数是否大于阈值。然后将原来的数据进行一次转移，转移的时候，并不是进行一次重新hash，1.7的时候进行数据转移的时候会造成数链表上的会发生一次数据的顺序发生反向，在 多线程的时候会造成数据反向，所以也会造程死循环。、、、



hash：是有条件的？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？/

1.8的时候数据的顺序不会发生变化。？？？？？？？？？？？？？？？？？？/







CurrentHashMap   为什么不使用hashtable？

currentHashMap是采用了分段锁，效率会比hashtable高。

1. 7    1.8   几次hash？

   



CAS优缺点   ABA

因为每次都是在修改数据的时候，判断数据是不是发生变化，如果发生了变化，就不进行修改，否则就进行修改。如果线程竞争比较激烈 的时候就会造成大量的重复计算。

ABA问题，数据在进行 查询的时候是一样的，但是数据确实在这个期间发生了变化，处理方式就是加版本号。



Synchroiyed   Relock  

syn是一个重量级的锁，它可以解决线程安全 的问题，可以保证数据的可见/原子/并且防止指令的重排序，volite可以保证两条，但是不保证原子性。

线程执行数据的时候，如果加锁了，它的执行过程是：加锁/read/load/use/assign/存储/write/释放锁

volite并不会这样，他在修改的时候进行一次比较，如果一样就进行修改，然后会将数据刷新到主内存，但是多线程的时候，数据修改完成，准备刷新到主内存的时候线程进行了切换。数据就会发生问题。



解决方法，采用syn



原理：在syn中会有一个监听进入和监听退出，在枷锁代码的开头和结尾。unloack的时候会有一次数据刷新到内存的过程。











JUC包

ActomicInteger



嗅探会产生什么问题  总线风暴



MVCC   事务





垃圾回收算法  垃圾回收器



标记清除，

复制清除

分代清除



NIO  BIO



建造者