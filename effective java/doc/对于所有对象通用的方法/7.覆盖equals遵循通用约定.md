# 覆盖equals时遵循通用约定

覆盖equals方法看起来比较简单，覆盖会导致错误，会有严重的后果。所以最容易的做法就是不覆盖equals方法，这个时候，每个实例都只与自身相等。

## 不覆盖equals方法

- 期望的结果
    - 类的每个实例都是唯一的（因为没有复写，所有只有对象是同一个对象的时候相等，是对象相等，不是逻辑相等）
    - 不关心逻辑相等
    - 超类复写了equals，子类直接继承。
    - 类是私有的，那么equals是永远的调用不了的
    ```java
    @Override public boolean equals(Object o) {
        throw new AssertionError(); // Method is never called
    }
    ```

## 什么时候需要复写

- 有逻辑相等的概念，并且父类没实现。
- 还有一种是枚举类型，值和对象是唯一对应的。

## equals的等价关系

- 自反性
- 对称性
- 传递性
- 一致性
- 对于非null，x.equals(null)为false
