

# 覆盖equals时遵循通用约定

object是一个具体的类，主要是为继承设计的，它的所有方法都是非final的 ，并且有清晰的通用约定，它可以被子类重写，并且需要遵守约定，将无法于某些类进行一起使用。

覆盖equals方法看起来比较简单，覆盖会导致错误，会有严重的后果。所以最容易的做法就是不覆盖equals方法，这个时候，每个实例都只与自身相等。如果自定义类的时候需要定义的时候，必须定义equals和hashcode方法。

## 不覆盖equals方法

- 期望的结果
    - 类的每个实例都是唯一的（因为没有复写，所有只有对象是同一个对象的时候相等，是对象相等，不是逻辑相等，自己和自己是相同的）
    - 不关心逻辑相等
    - 超类复写了equals，子类直接继承，并且适用于子类。
    - 类是私有的，那么equals是永远的调用不了的
    ```java
    @Override public boolean equals(Object o) {
        throw new AssertionError(); // Method is never called
    }
    ```

## 什么时候需要复写

- 有逻辑相等的概念，并且父类没实现，这个时候就需要复写，通常是一个值类。
- 还有一种是枚举类型，值和对象是唯一对应的。

一般的期望值相等而不是引用相等。不仅仅可以满足需求，还可以满足map和set	

但是单例中可以不需要复写，只有一个实例。父类Object的equals方法,比较的是它的地址。hashcode也是通过地址进行散列的。

## equals的等价关系

- 自反性：自己对自己                                            找不到自己
- 对称性：A对B,B对A                                             找不到相同的
- 传递性:A对B,B对C,A对C
- 一致性：多次执行结果相同
- 对于非null，x.equals(null)为false

一旦违反了就会崩溃或者异常，并且很难定位。

- 违反了自反性，如果加入到一个集合中，就会认为并不存在这个实例。
- 违反对称性，相等达成一致
