

# 垃圾回收算法

## 判断对象已经死了

### 引用计数器

增加一个引用+1，减少一个引用-1，当为0的时候，就表示不在被任何对象所引用了。

### 可达性分析算法

明确：什么是GCroots？什么样的才可以看作是GCroots

- 栈中的引用
- 方法区的中的常量
- 方法区中的静态属性
- 本地方法栈中的引用对象

从GC roots开始走过的路径叫引用链。

## 引用

分为：强引用/软引用/弱引用/虚引用

强引用：类似于Object  o = new Object();垃圾就不会进行回收

软引用：描述一些有用但是非必须的，当内存将要发生溢出异常的时候就会进行二次回收，如果回收之后还不够，就会发生溢出异常

弱引用：无论内存够不够都会进行回收

虚引用：对于内存没有任何影响，仅仅是内存回收时候的接受一个通知。

## 回收算法

### 标记清除

会造成大量的内存空间浪费

### 复制算法

将内存空间分为两个部分，需要回收的时候将一半的覅之

### 标记整理

### 分代回收

一共分为eden  /servivor(from   to)/ 老年期，Eden区中的数据回收的概率比较大，经常会被回收。老年区的一般是长期不会被回收的 。、

执行过程：年轻区域的数据，经过一段时间之后只剩下了少部分，然后将他们复制到幸存区域。对eden进行一次垃圾处理。从此之后，每次经过一次垃圾回收，就将他们的年龄增加1,

eden又需要一次垃圾回收，如果幸存区域也有一个要回收，那么将form复制到to，然后将from和eden都回收

再次进行的 时候将to复制到from.将eden和to的都清除掉。

eden : from ：to 8:1:1

幸存to如果如果满了 ，就需要进入到老年代，进入老年代的还有一个15次的。

如果新生代存放不下，就会进入到老年代，如果老年代放不下了，就会执行一次full GC（伴随来的还有一次stop the world）

年轻代的回收一般比较少，使用的是复制算法，但是老年代的存活率比较高，一般使用的是标记清理和标记整理

![image-20200405182602982](images/image-20200405182602982.png)











