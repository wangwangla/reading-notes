# 进入设计模式

1.什么是设计模式？

设计模式是对软件中普遍存在的各种问题，提出的一个解决方案。

## 设计模式的是7大原则

7种设计模式的原则，其实也是一种规范。

### 单一原则

一个类只管理一个职责

```java
/**
 * 创建一个类，类中有运行的方式
 * 
 * 存在问题：
 *   - 传入一个交通工具，然后执行一个run方法，如果天上飞的，那就会有问题
 *   - 解决方法
 *      按照交通工具的不同进行分类即可。
 */
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle + " is run on the road");
    }
}
```

我们进行更改

```java
class RoadVehice{
    public void run(String vehicle){
        System.out.println(vehicle + " is run on the road");
    }
}

class SkyVehice{
    public void run(String vehicle){
        System.out.println(vehicle + " is fly on the sky");
    }
}
```

分析：上面的方式可以完成优化

**问题：**花销很大，需要在客户端修改，需要在服务端增加类 

**改进：**修改我们的vehice类，可以节约掉客户都的修改

```java
/**
 * version three
 *
 * 1.对于服务端代码是做了一定的修改
 * 2.违背了单一职责（类） 方法上仍然遵守
 */
class VehicleVersionThree{
    public void roadRun(String vehicle){
        System.out.println(vehicle + " is run on the road");
    }

    public void skyFly(String vehicle){
        System.out.println(vehicle + " is fly on the sky");
    }
}
```

**总结**

```chinese
/**
 * 总结：
 *  - 降低了类的复杂度
 *  - 提高了类的可读性，可维护性
 *  - 降低了变更引起的风险
 *  - 一般的，遵循单一职责，
 */
```



### 接口隔离原则

两个类相依赖，必须依赖它的最小接口

**违背的例子**

- Father

  ```java
  package com.designpatten.jiekougeli;
  
  public interface FatherVersion {
      void methodOne();
      void methodTwo();
      void methodThree();
      void methodFour();
  }
  ```

  

- son

  ```java
  public interface FatherVersionOne {
      void methodOne();
      void methodTwo();
      void methodThree();
      void methodFour();
  }
  
  class SonOne implements FatherVersionOne{
  
      @Override
      public void methodOne() {
  
      }
  
      @Override
      public void methodTwo() {
  
      }
  
      @Override
      public void methodThree() {
  
      }
  
      @Override
      public void methodFour() {
  
      }
  }
  
  class SonTwo implements FatherVersionOne{
  
      @Override
      public void methodOne() {
  
      }
  
      @Override
      public void methodTwo() {
  
      }
  
      @Override
      public void methodThree() {
  
      }
  
      @Override
      public void methodFour() {
  
      }
  }
  
  class SonThree {
      public void methodOne(FatherVersionOne fatherVersion){
          fatherVersion.methodOne();
      }
      public void methodThree(FatherVersionOne fatherVersion){
          fatherVersion.methodThree();
      }
      public void methodTwo(FatherVersionOne fatherVersion){
          fatherVersion.methodTwo();
      }
  }
  
  class SonFour {
      public void methodOne(FatherVersionOne fatherVersion){
          fatherVersion.methodOne();
      }
      public void methodFour(FatherVersionOne fatherVersion){
          fatherVersion.methodFour();
      }
  }
  
  ```

  son类只需要使用father的第一个方法，但是这样的实现是违背了接口隔离原则的。

  **优化：**

  ```java
  interface FatherVersionTwo {
      void methodOne();
  }
  interface FatherVersionTwo1{
      void methodFour();
  }
  interface FatherVersionTwo2{
      void methodTwo();
      void methodThree();
  }
  
  class SonOneVesionTwo implements FatherVersionTwo,FatherVersionTwo1{
  
      @Override
      public void methodOne() {
  
      }
  
      @Override
      public void methodFour() {
  
      }
  }
  
  class SonTwoVesionTwo implements FatherVersionTwo,FatherVersionTwo2{
  
      @Override
      public void methodOne() {
  
      }
  
      @Override
      public void methodTwo() {
  
      }
  
      @Override
      public void methodThree() {
  
      }
  }
  
  class SonThreeVesionTwo {
      public void methodOne(FatherVersionOne fatherVersion){
          fatherVersion.methodOne();
      }
      public void methodThree(FatherVersionOne fatherVersion){
          fatherVersion.methodThree();
      }
      public void methodTwo(FatherVersionOne fatherVersion){
          fatherVersion.methodTwo();
      }
  }
  
  class SonFourVesionTwo {
      public void methodOne(FatherVersionOne fatherVersion){
          fatherVersion.methodOne();
      }
      public void methodFour(FatherVersionOne fatherVersion){
          fatherVersion.methodFour();
      }
  }
  ```



接口隔离原则：类和类之间的关系是通过接口进行实现的。需要建立在最小接口上，也就是使用不到的方法不要继承

**处理方法：**我们将接口进行拆分



































- 