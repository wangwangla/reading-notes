# 工厂设计模式

创建对象使用new之外，还有更多的方法来进行。实例并不是公开的，初始化容易造成耦合。（使用的是实例，而不是实现）

## 第一个版本

```java
//我们根据传入的值，然后创建实例
//switch只是在数值类型的时候可以使用，java 8 之后加入了一个String类型。所以使用下面的方式，是有条件的
public Father getInstance(String intanceName){
    switch(intanceName){
        case "name1":
            return new Demo01();
        ……

    }
}
```

还有一种写法是通过if else进行判断。

**question：**

- 是不是容易扩展   否
- 是不是容易修改   否

违背了扩展开放修改关闭

## 比萨

```java
Pasa getInstance(){
    Pasa p = new Pasa();
    p.prepare();
    p.bake();
    p.cut();
    p.box();
    return p;
}
```

为了有更多的

```java
Pasa getInstance(Type type){
    Pasa p ;
    if(type == "XX1"){
        p = new Pasa1();
    }else if(type == "XX2"){
        p = new Pasa2();
    }
    p.prepare();
    p.bake();
    p.cut();
    p.box();
    return p;
}
```

**总结：**

存在问题 万一pasa没有实例化怎么办，“==”可以实现吗。

## 继续探索

如果中间突然去掉一种该怎么办？？

我们现在将if判断部分，进行封装，我们将那一块的封装到工厂种。

- 修改之后的

```java
class Pasa{
    private PasaFactory pasaFactory;
    public Pasa(PasaFactory pasaFactory){
        this.pasaFactory = pasaFactory;
    }

    Pasa getInstance(Type type){
        //Pasa p = PasaFactory.getInstance(type);
        这个地方也可以在此封装
        pasaFactory.getInstance();
        // if(type == "XX1"){
        //     p = new Pasa1();
        // }else if(type == "XX2"){
        //     p = new Pasa2();
        // }
        p.prepare();
        p.bake();
        p.cut();
        p.box();
        return p;
    }
}
```

## 雷人消息

简单工厂不是设计模式
门店通过调用过程创建对象

- 创建一个store

```java
public abstract class PizzaStore{
    public Pizza orderPizza(String type){
        Pizza pizza ;
        pizza = createPizza(type);

        pizza.XXX();
        return pizza;
    }

    //工厂
    public Pizza createPizza(String type);
}
```

### 允许子类决定对象

