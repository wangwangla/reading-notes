# 工厂设计模式

创建对象使用new之外，还有更多的方法来进行。实例并不是公开的，初始化容易造成耦合。（使用的是实例，而不是实现）

工厂模式分类

- 简单工厂
- 工厂方法
- 抽象工厂

使用过程代替new创建对象，对对象创建进行统一的管理。

## 第一个版本

```java
//我们根据传入的值，然后创建实例
//switch只是在数值类型的时候可以使用，java 8 之后加入了一个String类型。所以使用下面的方式，是有条件的
public Father getInstance(String intanceName){
    switch(intanceName){
        case "name1":
            return new Demo01();
        ……

    }
}
```

还有一种写法是通过if else进行判断。

**question：**

- 是不是容易扩展   否
- 是不是容易修改   否

违背了扩展开放修改关闭

## 比萨

```java
Pasa getInstance(){
    Pasa p = new Pasa();
    p.prepare();
    p.bake();
    p.cut();
    p.box();
    return p;
}
```

为了有更多的

```java
Pasa getInstance(Type type){
    Pasa p ;
    if(type == "XX1"){
        p = new Pasa1();
    }else if(type == "XX2"){
        p = new Pasa2();
    }
    p.prepare();
    p.bake();
    p.cut();
    p.box();
    return p;
}
```

**总结：**

存在问题 万一pasa没有实例化怎么办，“==”可以实现吗。

## 继续探索

如果中间突然去掉一种该怎么办？？

我们现在将if判断部分，进行封装，我们将那一块的封装到工厂种。

- 修改之后的

提供工厂创建实例，使用的时候只需要调用方法就可以了。

```java
class Pasa{
    private PasaFactory pasaFactory;
    public Pasa(PasaFactory pasaFactory){
        this.pasaFactory = pasaFactory;
    }

    Pasa getInstance(Type type){
        //Pasa p = PasaFactory.getInstance(type);
        这个地方也可以在此封装
        pasaFactory.getInstance();
        // if(type == "XX1"){
        //     p = new Pasa1();
        // }else if(type == "XX2"){
        //     p = new Pasa2();
        // }
        p.prepare();
        p.bake();
        p.cut();
        p.box();
        return p;
    }
}
```

## 雷人消息

简单工厂不是设计模式
门店通过调用过程创建对象

- 创建一个store

```java
public abstract class PizzaStore{
    Pizza pizza ;
    private Pizza orderPizza(String type){
        pizza = createPizza(type);

        pizza.XXX();
        return pizza;
    }

    //工厂
    public Pizza createPizza(String type);
}
```

### 允许子类决定对象

现在上面基本实现了框架，现在我们可以让他们，在不同的蛋糕店生成出不同类型的蛋糕

创建不同类的的，这个现在很明显是创建一个产品族

创建不同类型的pizza

```java
public class ChinesePiza extends PizzaStore{
    public Pizza createPizza(String type){
        if("test".equals(type)){
            
        }else if("test1".equals(type)){
            
        }else{

        }
    }
}
```

总结：

store下面有各类的蛋糕生产，在在蛋糕店中进行蛋糕生产。

```java
class SStore extends Store{
    public 蛋糕 getInstance(){
        if("".equals()){
            蛋糕 = new 蛋糕1();
        }else if(""){

        }……
    }
}
```

如果生成不同口味的

```java
class SStore extends Store{
    public 蛋糕 getInstance(){
        if(){
            if("".equals()){
                蛋糕 = new 蛋糕1();
            }else if(""){

            }……
        }else{
            
        }
    }
}
```

## 简单工厂

用来生产同一个等级的产品。
不适应简单工厂的时候

```java
main(){
    Car c1 = new Audi();
    Car c2 = new Byd();
}
```

简单工厂模式也叫静态工厂模式，根据接受不同的参数返回不同的实例。对于增加新的产品无能为力。

```java
public class CarFactory{
    public static Car createCar(String type){
        Car c = null;
        if("X1".equals(type)){
            c = new Audi();
        }else if("X2".equals(type)){

        }
        return c;
    }
}

或者

public class CarFactory{
    public static Car createAudi(){
        return new Audi();
    }
    ……
}
```

简单说就是使用静态方法返回不同的值

## 工厂方法模式

用来生成同一等级中固定的产品，支持增加任意的产品
简单点说就是不同的工厂生成不同的东西，需要相应的东西，必须有某个工厂才可以。

```java
public interface Car{
    public void run();
}

public class Audi impelements Car{
    public void run(){
        Syso("Audi run");
    }
}

……

public interface CarFactory{
    public Car createFactory();
}

public class AudiFactory implement CarFactory{
    public Car createFactory(){
        System.out.println("");
    }
}

public Client{
    main(){
        Audi a = AudioFactory.createFactory();
    }
}
```

## 抽象工厂方法

用来生产不同产品族的全部产品，支持增加产品族，不增肌新的产品

> 举个例子：

低蛋糕店可以生成白面包/黄面包等
高级蛋糕点可以定制蛋糕

客户端就可以直接的调用方法，高级蛋糕店和低级蛋糕店。