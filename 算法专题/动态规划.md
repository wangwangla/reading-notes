# 动态规划

动态规划一般会有以下特点：计数/最大最小值/存在性。

- 计数
  - 有多少种方式走到右下角
  - 多少种方法选出k个数使得和是sum
- 最大最小值
  - 从左上角到右下角最大的数字和
  - 最长XX序列
- 存在性
  - 取石子，先胜利
  - 能不能取出k个数使得和为sum.



## 例题部分

**题目**：有三种硬币，分别是面值为2元，5元，7元，每种硬币足够多，组成K，如何使得对放不需要找钱

**分析：**

- 最后一步有个值k1可以到底K,存在k2使得取得k2到达k-k1。
- 转移方程f[x] = min(f[x-2]+1,f[x-5]+1,f[x-7]+1);
- 边界：f[x-2],f[x-5],f[x-7]
- 初始值f[0]不使用硬币

**代码**

```java
public static void method(int arr[],int K){
    //1.创建dp 从0开始，一直取值到k;
    int dp[] = new int[K+1];
    //初始值
    dp[0] = 0;
    //需要取最小值，所以存入最大值
    for (int i = 1; i <= K; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int j = 0; j < arr.length; j++) {
            //保证dp[i-arr[j]]不会越界
            if (arr[j]<=i){
                //这个是可以组成的
                if (dp[i-arr[j]]!=Integer.MAX_VALUE){
                    //取当前值 使得总数最少。
                    dp[i] = Math.min(dp[i],dp[i-arr[j]]+1);
                }
            }
        }
    }
    //最后一个为最小值
    System.out.println(dp[K]);
}
```



**题目：**

有n个石头分别在0到n-1位置上，青蛙在石头0，想到达n-1，在i个石块上，可以跳ai个位置，求是不是可以跳到n-1;

胜负问题



**分析：**

- 最后一次跳到了>=n-1的位置，
- 转移方程：f[i] = [j+arr[j]]>i&&f[j]   它可以走到 ，并且加上当前的值，大于目标的值。
- 初始值为true

**代码：**

```java
    public void method(int arr[]){
        //0到k-1,所以创建k的数组就可以了
        boolean dp[] = new boolean[arr.length];
        //遍历结果
        dp[0] =  true;
        for (int i = 1; i < arr.length; i++) {
            dp[i] = false;
            for (int j = 0; j < i; j++) {
                if (dp[j]&&j+arr[j]>i)
                    dp[i] =true;
            }
        }
    }
```

**题目：**机器人从左上角走到右下角，走的方式。

**分析：**

- 来源上方和左方

- 转移方程

  ```java
  f[i][j] = f[i-1][j]+f[i][j-1]
  ```

  

- 初始值

  ```java
  f[0][j] = 1;
  f[i][0] = 1;
  ```

**代码：**

```java
    public void mathod(int arr[][]){
        //这个不需要创建多余的空间
        int dp[][] = new int[arr.length][arr[0].length];
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (i==0||j==0){
                    dp[i][j] = 1;
                }else {
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        System.out.println(dp[arr.length-1][arr[0].length-1]);
    }
```

